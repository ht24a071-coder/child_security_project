"""
RLS Rpy Writer â€” generates .rpy files with the RLS auto-generated header.

All output .rpy files are placed *inside* the rls/ directory to maintain
strict file-ownership separation.
"""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from rls.core.file_manager import RLSFileManager

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

RLS_HEADER = "# AUTO-GENERATED BY RLS â€” DO NOT EDIT"
RLS_HEADER_COMMENT = (
    "# This file is managed by Ren'Py Layout Studio.\n"
    "# Manual changes will be overwritten on next RLS export.\n"
    "# For custom logic, use rls_hooks.rpy instead.\n"
)


class RpyWriter:
    """Writes .rpy files with the mandatory RLS header.

    Uses an ``RLSFileManager`` internally to guarantee writes stay inside
    the ``rls/`` directory.
    """

    def __init__(self, file_manager: RLSFileManager) -> None:
        self._fm = file_manager

    # -- public API ---------------------------------------------------------

    def write_rpy(self, path: str | Path, body: str) -> None:
        """Write a .rpy file with the RLS header prepended.

        Parameters
        ----------
        path:
            Absolute or relative path to the target .rpy file.
            Must be inside the ``rls/`` directory.
        body:
            The Ren'Py screen-language code to write (without the header).

        Raises
        ------
        WriteProtectionError
            If *path* is outside the ``rls/`` directory.
        """
        full_content = self._build_content(body)
        # Delegate to file manager which enforces ownership rules
        self._fm.safe_write(path, full_content)

    def has_rls_header(self, path: str | Path) -> bool:
        """Return True if the file at *path* starts with the RLS header."""
        path = Path(path)
        if not path.exists():
            return False
        try:
            first_line = path.read_text(encoding="utf-8").split("\n", 1)[0]
            return first_line.strip() == RLS_HEADER
        except (OSError, UnicodeDecodeError):
            return False

    # -- helpers ------------------------------------------------------------

    @staticmethod
    def _build_content(body: str) -> str:
        """Combine header + body into the final file content."""
        parts = [RLS_HEADER, RLS_HEADER_COMMENT]
        # Ensure a blank line between header block and body
        body_stripped = body.strip()
        if body_stripped:
            parts.append("")
            parts.append(body_stripped)
        parts.append("")  # trailing newline
        return "\n".join(parts)

    def __repr__(self) -> str:
        return f"RpyWriter(rls_dir={self._fm.rls_dir!r})"
